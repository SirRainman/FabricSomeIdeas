# 写在前面

## 跨联盟需要解决的问题

多个联盟之间，需要进行信息共享。当本联盟需要访问其他联盟中的信息时，只需要访问本联盟中其他联盟提供的接口就可以了。

接口的体现形式：

1. 在本联盟中设置访问其他链盟的客户端，通过其他联盟的客户端访问其他联盟中的信息。
2. 在本联盟中设置其他联盟的轻节点。



之所以是通过其他联盟的客户端，或通过轻节点的方案，是因为：

1. 一个联盟可能并不希望将自己的数据，放到其他联盟中
2. 若一个联盟需要访问其他联盟中的数据，就要维护其他联盟中的所有数据，成本太大。



因此，问题最终转化为

* 在不存储其他联盟中的数据的情况下，如果快速且有效的查询其他联盟中的信息



## 其他联盟客户端方案分析：

优点：

1. 在授权之后，可以得到某个证照的具体信息，信息完整度高。

缺点：

1. 时延长：在查询过程中，有两个查询周期（客户端在本联盟中查询不到结果后，通过其他联盟的客户端进行二次查询）

## 轻节点的方案分析：

优点：

1. 只需要验证其他联盟中是否有一笔历史交易就可以了，效率高。

缺点：

1. 只可以返回是否具有其他联盟中，是否存在一笔我们想要验证的历史交易。

### 轻节点验证-需要解决的问题

轻节点的功能是：保存一个链中所有节点的区块头部分，不保存区块体部分。可以验证一笔交易是否存在于链上。

以太坊轻节点问题：

1. 当需要验证某一笔交易是否存在于链上时，以太坊的轻节点是怎么做的？
2. 为什么轻节点只保存区块头？他保存区块头有什么作用？
3. 以太坊轻节点只保存区块头部分，轻节点怎么确认该笔交易在哪一个区块上？
4. 以太坊轻节点在确认某一笔交易在链上时，他需要向全节点发送一个对该历史交易的验证请求，然后全节点该笔交易在某一个区块上的merkel proof返回给轻节点，轻节点再根据Merkel proof进行验证。
   在这个过程中，轻节点还需要向全节点发送一次验证请求。如果迁移到了fabric中，该轻节点还需要向peer发送一次验证请求的话，那么这个方案和直接像peer节点进行查询一笔历史交易的代价有什么不同？



Fabric轻节点的问题：

1. fabric的区块头只有三部分，如何利用这三部分进行轻节点的验证工作？[关于区块构造部分源码解析](./1-BlockStructure.md)

### 轻节点收集区块头-需要解决的问题：

Fabric中没有轻节点的概念，fabric中节点可以分为：client/peer/orderer。

1. 概念性问题：如果要在fabric中设计一个轻节点，这个轻节点的类型是不是更偏向于peer节点？
   - 答：这个“轻节点”更像是fabric中的peer节点
     轻节点中需要保存所有block的区块头部分，因此，在fabric中它的体现形式更像是peer节点的形式。因为peer节点在fabric中存储了区块信息。此外它表现为peer节点的形式好另外一个好处就是可以运行智能合约。

由于这个轻节点更像是一个peer节点，因此我们需要对fabric中peer节点进行源码上面的改造。

- 改造的最终目的是：**使fabric能够定期同步存储peer集群中所有区块的区块头数据。**



问题，因为peer节点之间是通过Gossip协议进行同步区块信息的：

1. 首先，必要容易忽略的一个问题是，在gossip中，进行节点之间的同步通信工作是可以通过选举完成的。选举成功之后成为主节点，负责与orderer节点进行通信，从orderer哪里拿到区块之后再分发给其他的peer。因为我们所作的轻节点只需要同步区块头，不需要承担这么重要的任务，所以我们需要对轻节点的gossip的选举部分进行改动，不要让他选举为负责与orderer进行沟通的主节点。
   可以通过设置gossip旁观者解决这个问题。
2. 我们需要在peer节点的Gossip负责监听的端口开始追踪工作。
3. peer节点监听到有区块进来后，对区块进行存储时我们需要对他的处理区块的代码进行改动。

---

# Fabric交易的生命周期

在这里贴一下贴一下交易的生命周期，以便自己有一个宏观的认识

![](F:/Rain/Post-Graduate/区块链/fabric2-doc-learn/images/peers-app.png)

app提交交易流程：

1. Hyperledger Fabric SDK 通过 APIs 使应用程序能够连接到 peers。
   application生成交易提案proposal，其中包含本次交易要调用的合约标识、合约方法和参数信息以及客户端签名等。
2. 在交易提案能够被网络所接受之前，app必须得到背书策略所指定的peers的背书。peer使用proposal来调用 chaincode，从而生成交易的proposal response。
   1. peer 根据 proposal 的信息，调用用户上传的链码
   2. 链码处理请求，将请求转化位对账本的读集合与写集合。
   3. peer 对读集合和写集合进行签名，并将proposal response 返回给app SDK。
3. application接收到了一定数量经过背书后的proposal responses，并将读集合与写集合和不同节点的签名拼接在一起，组成envelope（在这里envelope才是一个真正的tx）。
4. application提交envelope到order节点后，sdk并监听peer节点的块事件。
   1. 在orderer集群中envelope会被排序，当orderer收集到足够多的envelope后，生成新的区块。
   2. orderer将区块广播到peer集群中的分布式账本中。
      注：不是每个 Peer 节点都需要连接到一个排序节点，只需要一个peer主节点连接到order就可以了，然后Peer中的主节点可以使用 gossip 协议将区块关联到其他节点。（gossip的另外一个应用就是组织间的peer的相互通信）
   3. 每个peer节点将独立地以确定的方式验证区块，以确保账本保持一致。具体来说，通道中每个peer节点都将验证区块中的每个交易，以确保得到了所需组织的节点背书，也就是peer节点的背书和背书策略相匹配，并且不会因最初认可该事务时可能正在运行的其他最近提交的事务而失效。无效的交易仍然保留在排序节点创建的区块中，但是节点将它们标记为无效，并且不更新账本的状态。
5. 在peer集群收到区块并进行验证之后，peer向sdk发送新收到的区块和验证结果。
6. sdk根据事件的验证结果，判断交易是否成功上链。

## 现阶段需要解决的问题：

需要弄清fabric中，查询/某一笔交易的过程。

1. fabric中可以直接查询一个历史交易吗？
   fabric是可以通过txid查询到一个交易的具体信息。具体是通过调用部署在peer节点上的系统链码qscc中的getTransactionByID()方法实现
2. fabric查询一个对象的信息是从key-value数据库中得到的吗？[读取kv数据库的源码分析](./2-ReadKV.md)
   是的，一般是使用couchdb的语法，从couchdb的数据库中读取到一个对象的最终状态。

